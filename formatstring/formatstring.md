---
title: 格式串溢出
tags: Exploiting Format String Vulnerabilities
grammar_cjkRuby: true
---
翻译文献：[https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf][1]

# 1.引言
这篇文章讲解了在2000年下半年震惊了安全社区的一件大事的本质。被认为是“格式字符串漏洞”，一种新类型的漏洞被揭露，并在其中发现了一波的可利用漏洞，从微小的工具到大型服务应用程序。

 这个文章将尝试解释这个漏洞的结构，并在之后用这些知识来建立复杂的漏洞。它将给你们展示如何发现在c语言的源代码中的格式字符串漏洞，以及为什么这个新类型的漏洞比普通的缓冲区溢出漏洞更加危险。
	   
这篇文章基于一个我在德国柏林的第十七届Chaos Communication Congress（Europe's largest association of hackers）。在这个演讲之后，我收到了数不清的翻译请求它并收到了积极的反馈。这些激励我校订这个文件，更新并修正细节并做为它做一个更有用latex版本。
	   
这篇文章包含了绝大多数在别的文章里提到的内容，增加了一些可利用的技巧。它是最新的，欢迎反馈。所以以后你阅读它请给我发邮件反馈，想法以及任何非骚扰内容都可以发送给 http://www.team-teso.net/
	   
这篇文章的第一部分是格式串溢出的历史和尝试，随后详细说明如何在源代码中发现和避免这样的漏洞。然后开发了一些基本技术来应对这些漏洞，从而产生了可利用方法。这个方法被改进，并实际应用在特殊的情景，来允许你利用近乎至今发现的所有种类的格式字符串漏洞。
	  
正如每一个过去漏洞一样，随着时间的的流逝而发展，新的技术也被创造出来，通常因为旧的技术在某种情况下不起作用。一些人真正值得受到称赞，因本文中大量被提到的技术。显著影响了我写作的是tf8，他写了第一个格式字符串漏洞，portal，他在他的文章中开发和研究了可利用，digit，他发现了如今已知的大多数关键的远程格式字符串漏洞，而smiler，则开发了复杂的爆破技术。
	   
虽然我也提供了一些技巧。但没有这些人极大的帮助，评论和技巧，包括理论上或者形式上的利用向我展示的，这篇文章不可能存在。感谢，我也感谢无数评论，检验和改进这篇文章的人。
	   
更新和改正的版本将会出现在TESO Security Group的主页。
	   
## 1.1缓冲区溢出 vs 格式字符串漏洞
由于过去几乎所有的关键漏洞都是缓冲区溢出的一种类型，因此可以与这种新型漏洞进行严重和		低等级漏洞的比较:		
	![][2]
  			
## 1.2统计：2000年的重要格式字符串漏洞

为了强调格式字符串漏洞对于2000年的危险影响，我们在此列出来最常被利用的公开漏洞。
	![][3]
			
在撰写本文时，仍然存在许多未知或未公开的漏洞，在接下来的两三年内，格式字符串漏洞将有助于统计发现新的漏洞。正如我们将要看到的，使用更复杂的工具可以很容易的自动发现它们，并且可以认为，对于尚未公开的代码中的大多数漏洞，存在可利用的漏洞。

还有一些方法可以在应用程序中发现此类漏洞，这些漏洞仅作为二进制文件提供。为此，在Halvar Flakes优秀的二进制审计演讲中使用并详细解释了找到“论证缺陷”的更通用的方法。
	  
	  
# 2.格式函数
格式函数是一种特殊的ANSI C函数，它接受可变数量的参数，从所谓的格式字符串。当函数评估格式字符串时，它访问给函数的额外参数。它是一个转换函数，用于表示人类可读字符串表示中的原始C的数据类型。它们几乎用于任何c程序，用于输出信息，打印错误消息或处理字符串。

在本章中，我们讲介绍格式函数使用中的典型漏洞，正确的用法，一些参数以及格式字符串漏洞的一般概念。
		
## 2.1一个格式字符串漏洞看起来像什么？
		
如果攻击者能够将格式字符串部分或全部提供给ANSI C格式函数，则会出现格式字符串漏洞。通过这样做，格式函数的行为被改变，并且攻击者可以控制目标应用程序。

在下面的例子中，字符串用户由攻击者提供 -- 他可以控制整个ASCIIZ字符串，例如通过使用命令行参数。
``` 
	Wrong usage:	//错误用法
int
func (char *user)
{
	printf (user);
}
	Ok:
int
func (char *user)
{
	printf ("%s", user);
}

```

## 2.2格式函数系列
ANSI C 定义中定义了许多格式函数。有一些基本的格式字符串函数，更复杂的函数基于这些函数，期中一些不是标准的一部分，但是可以广泛使用。

真正的家庭成员：
		fprintf —— prints to a FILE stream
		printf —— prints to the 'stdout' stream
		sprintf —— pringts into a string
		snprintf —— prints into a string with length checking
		vfprintf —— print to a FILE stream from a va_arg structure
		vprintf —— prints to 'stdout' from a va_arg structure
		vsprintf —— prints to a string from a va_arg structure
		vsnprintf —— prints to a string with length checking  from a va_arg structure
结构亲属：
		setproctitle —— set argv[]
		syslog —— output to the syslog facility
		others like err\*,verr\*,warn\*,vwarn\*
		
## 2.3使用格式函数
为了理解这个漏洞在C代码的常见位置，我们必须检查格式函数的用途。

功能：
		用于将简单的C数据类型转换为字符串表示形式
		允许指定表示的格式
		处理结果字符串（shuchudao stderr,stdout,syslog...）格式

函数的工作原理：
		格式字符串控制函数的行为
		它指定了应打印的参数类型
		参数保存在堆栈中（推送）
		直接（按值）或间接（通过引用）保存

调用功能：
		必须知道它推送到堆栈的参数有多少，因为当格式函数返回时它必须进行堆栈校正

## 2.4什么是格式字符串
格式字符串是一个包含了文本和格式参数的ASCIIZ字符串。
		
例：
			
	printf ("The magic number is: %d\n",1911);
		
被打印的文本是“The magic number is:”，后跟格式参数“%d”，在输出中用参数“1911”替换。因此输出看起来像: The magic number is : 1911.

一些格式参数：
		![][4]
		
value:值  reference:参考、引用
“\”字符用于转义特殊字符，它在编译时由C编译器替换，替换转义序列二进制中合适的字符。格式函数无法识别这些特殊序列。

实际上，它们根本没有与格式函数有任何关系，但有时会混淆，就像它们被它们评估一样。
例：
			
		printf("The magic number is:\x25d\n"，23）；
上面的代码有效，因为‘\x25’在编译时用’%‘替换，因为0x25（37）是百分号字符的ASCII值。

# 2.5堆栈及其在格式字符串中的作用
格式函数的行为由格式字符串控制。该函数从堆栈中检索格式字符串所请求的参数。
	
	printf("Number %d has no address,number %d has: %08x\n"，i，a，&a);
在printf函数中，栈看起来像:		
![][5]
A    -->  格式字符串的地址
i      -->  变量i的值
a    -->  变量啊的值
&a  -->  变量i的地址

格式函数现在通过一次读取一个字符来解析格式字符串‘A’。如果它不是‘%’，则将字符复制到输出。如果是，则‘%’后面的字符指定应评估的参数类型。字符串“%%”具有特殊含义，用于打印转移字符‘%’本身。每个其他参数都与数据有关，数据位于堆栈中。
			
			
# 3.格式化字符串漏洞
格式字符串漏洞的泛型类是“引导问题”。如果将两种不同类型的信息通道合并为一种，则会出现此类漏洞，并使用特殊转义字符或序列来区分当前活动的通道。大多数情况下，一个通道是一个数据通道，它不会被主动解析而只是被复制，而另一个通道是一个控制通道。

虽然这本身并不是一件坏事，但如果攻击者能够提供一个频道中使用的输入，它很快就会成为一个可怕的安全问题，通常存在错误的逃逸或逃避例程，或者他们监督一个级别，例如格式字符串漏洞。所以简言之：引导问题本身并不是安全漏洞，但它们会是漏洞被利用。

未来说明这背后的一半问题，这里有一个常见的通道问题表：

![][6]
		
回到特定格式字符串漏洞，有两种典型情况，可能会出现格式字符串漏洞：

类型1（如linux rpc.statd，irix telnetd）。这里的漏洞位于syslog函数的第二个参数中。格式字符串部分是用户提供的。
``` 
char tmpbuf[512];
snprintf (tmpbuf, sizeof (tmpbuf), "foo: %s", user);
tmpbuf[sizeof (tmpbuf) - 1] = ’\0’;
syslog (LOG_NOTICE, tmpbuf);
```

类型2（如wu-ftpd,Qualcomm Popper QPOP 2.53）。这里部分或完全用户提供的字符串间接传递给格式函数。
``` 
int Error (char *fmt, ...);
...
int someotherfunc (char *user)
{
...
Error (user);
...
}
```

虽然第一张类型的漏洞可以通过自动化工具（例如pscan或者TESOgcc）安全地检测到，但只有在工具被告知函数“错误”被用作格式函数时才能找到第二种类型的漏洞。

（但是，你可以自动执行在源代码中识别额外格式函数及其参数的过程，因此找到格式字符串漏洞的所有过程都可以完全自动运行。你甚至可以概括，如果有这样的工具可以执行此操作并且在源代码中找不到格式字符串漏洞，那么你的源代码就没有任何此类漏洞。缓冲区溢出的情况并非如此，即使有经验的审计员进行手动审计也可能会漏掉漏洞，并且没有可靠的方法来自动检查漏洞。）
		
## 3.1我们现在控制什么？
通过提供格式字符串，我们可以控制格式函数的行为。我们现在必须检查我们能够控制什么，以及如何使用此控件将对流程的部分控制扩展到对执行流程的完全控制。
		
## 3.2该计划的崩溃
使用格式字符串漏洞的简单攻击是使进程崩溃。这对某型事情很有用，例如崩溃转储核心的守护进程，并且coredump（用于段错误调试）中可能有一些有用的数据。或者在一些网络攻击中，使服务无响应是有用的，例如在DNS欺骗时。但是，可能会对崩溃过程感兴趣。在几乎所有的unix系统中，内核都会捕获非法指针访问，并且进程将发送SIGSEGV信号。通常程序终止并转储核心。

通过使用格式字符串，我们可以通过提供如下的格式字符串轻松触发一些无效指针访问：
	
	printf ("%s%s%s%s%s%s%s%s%s%s%s%s");

因为‘%s’显示来自堆栈上提供的地址的内存，其中还存储了许多其他数据，所以我们从非映射的非法地址读取的可能性很高。此外，大多数格式函数实现都提供‘%n’参数，该参数可用于写入堆栈上的地址。如果这样做了几次，它也应该可靠地产生崩溃。
			
## 3.3查看进程内容
如果我们看到格式函数的回复 - 输出字符串 - ，我们可以从中手机有用的信息，因为它是我们控制的行为的输出，我们可以使用这个结果来获得我们的格式字符串的概述是否以及流程布局如何。这对于各种食物可能是有用的，例如为真正的利用找到正确的偏移或者只是重建目标进程的堆栈帧。

### 3.3.1查看堆栈
我们可以使用如下格式字符串显示堆栈内存的某些部分：
	
	printf ("%08x.%08x.%08x.%08x.%08x\n"）；

这是有效的，因为我们这是printf函数从堆栈中检索五个参数并将它们显示为8为填充的十六进制数字。因此可能的输入可能如下所示:
	
	40012980.080628c4.bffff7a4.00000005.08059c04

这是堆栈内存的部分转储，从当前底部向上开始到堆栈顶部 - 假设堆栈向低地址增长。根据格式字符串缓冲区的大小和输出缓冲区的大小，你可以使用此技术重建堆栈内存的跟多或更少的大部分内容。在某些情况下，你甚至可以检索整个堆栈内存。

堆栈转储提供有关程序流和本低函数变量的重要信息，对于找到成功利用的正确偏移量可能非常有用。
		
### 3.3.2在任何位置查看内存
还可以窥视与堆栈寄存器不同的存储器位置。为此，我们必须使用格式函数仓我们可以提供的地址显示内存。这给我们带来了两个问题：首先，我们必须找到一个格式参数，它使用一个地址（通过引用）作为堆栈参数并从哪里显示内存，我们必须提供该地址，我们很幸运，在第一种情况下，因为‘%s’参数就是这样，它从堆栈提供的地址显示内存 - 通常是ASCIIZ字符串。所以剩下的问题是，如何将堆栈上的地址放到正确的位置。

我们的格式字符串通常位于堆栈本身，因此我们已经接近完全控制格式字符串所在的空间。（在这种情况下，我们假设我们可以完全控制整个字符串。我们稍后会看到，部分控制，过滤字符，包括NUL字节的地址和类似问题无论何时利用格式字符串漏洞）格式函数在内部维护一个指向当前格式参数的堆栈位置的指针。如果我们能够将这个指针指向我们可以控制的内存空间，我们可以为‘%s’参数提供一个地址。要修改堆栈指针，我们可以简单地使用通过打印垃圾来“挖掘”对炸弹虚拟参数：
	
	printf ("AAA0AAA1\_%08x.%08x.%08x.%08x.%08x")；

’%08x‘参数将格式函数的内部堆栈指针朝向堆栈顶部增加。在这个增加的参数或多或少之后，堆栈指针指向我们的内存：格式字符串本身。格式函数世中保持最低的堆栈帧，因此如果我们的缓冲区完全位于堆栈上，它肯定位于当前堆栈指针之上。如果我们正确地选择‘%08x’参数的数量，我们可以通过在字符串中附加‘%s’来显示来自于任何地址的内存。在外面的例子中，地址是非法的，将是‘AAA0’。让我们用真实的替换它。

例：
	地址 = 0x08480110
	地址（编码为32位字符串）：“\x10\x01\x48\x08”
		
		printf ("\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|")；
将从0x08480110转储内存，直到达到NUL字节。通过动态增加内存地址，我们可以映射出整个进程空间。甚至可以创建像远程进程的图像那样的coredump并从中重建二进制文件。找到不成功的利用尝试的原因也很有帮助。

如果我们无法通过使用4字节的pops（‘%08x’）来打到去恶气呃的格式字符串边界，我们必须通过预先添加一个，两个或三个垃圾字符来填充格式字符串（我们不能按字节顺序移动堆栈指针，而是移动格式字符串本身，这样它就位于堆栈指针的为四字节边界上，我们可以通过四个字节的倍数来实现它）这类似于缓冲区溢出漏洞中的对齐。
		
## 3.4覆盖任意内容
利用的圣杯是控制一个进程的指令指针。在大多数情况下，指令指针（通过从命名为IP 或PC）是CPU中的寄存器，不能直接修改，，因为只有机器指令才能更改它。但是，如果我们能够发布这些机器指令，我们就可以控制它。所以我们不能直接控制这个过程。通常情况下，该进程比攻击者目前拥有的进程更多。

相反，我们必须找到修改指令指针的指令，并对这些指令如何修改它们产生影响。这听起来很复杂，但在大多数情况下它非常简单，因为有些指令从内容中获取指令指针并跳转它。因此，在大多数情况下，控制存储指令指针的存储器的这一部分是控制指令指针本身的前提。这是大多数缓冲区溢出的工作方式：

在两个阶段的过程中，首先覆盖保存的指令指针，然后程序执行合法的指令，将控制转移到攻击者提供的地址。

我们将使用格式字符串漏洞检查实现此目的的不同方法。
		
### 3.4.1利用-类似于常见的缓冲区溢出
格式字符串漏洞有时会提供一种解决缓冲区长度限制的方法，并允许类似于常见缓冲区溢出的利用。下面的代码出现在QPOP 2.53和bftpd中：
``` 
{
char    outbuf[512];
char    buffer[512];
sprintf (buffer, "ERR Wrong command: %400s", user);
sprintf (outbuf, buffer);
}
```
这种情况通常隐藏在reallife代码的深处，并不像上面的例子中所示那么明显。通过提供特殊格式字符串，我们可以规避‘%400s’限制：
	
	"%497d\x3c\xd3\xff\xbf<nops><shellcode>"
		
一切都类似于葡萄糖的缓冲区溢出漏洞利用字符串，只是开头 - “%497d” - 是不同的。在正常的缓冲区溢出中，我们覆盖堆栈上的函数帧的返回地址。当拥有此帧的函数返回时，它将返回到我们提供的地址。地址指向“<nop>”空间内的某个位置。有很好的文章描述了这种开发方法，如果这个例子你还不是足够清楚，你应该先仔细阅读一篇文章，例如http://www.thehackerschoice.com/papers/OVERFLOW.TXT

它创建一个长度为497个字符的字符串。与错误字符串（“ERR Wrong command:”）一起，这超出了outbuf缓冲区四个字节。尽管‘user’字符串只允许长达400个字节，但我们可以通过妄用格式字符串参数来扩展其长度。由于第二个sprintf没有检查长度，因此可以用来图片output的边界。现在我们编写一个返回地址（0xbfffd33c），并以旧的一直方式利用它，就像我们对任何缓冲区溢出一样。虽然任何允许“扩展”原始格式字符串的格式参数（例如“50d”，“%50f”或“%50s”）都可以，但是需要选择不取消引用指针的参数或者可能导致被零除。这派出了“%f”和“%s”。我们留下证书输出类型：“%d”，“%u”和“%x”。

GNU C库包含一个错误，如果你使用会导致崩溃。像“%nd”这样的参数，其中n大于1000，这是远程确定GNU C库存在的一种方法。如果使用“%.nd”，它将正常工作，除非使用非常高的值。有关可以在“%nd”和“%.nd”中使用的长度的深入探讨，请参考http://www.security.is/

### 3.4.2利用 - 通过纯格式字符串
如果我们没有可能的方法来应用刚刚提到的简单利用方法，我们仍然可以利用这个过程。通过这样做，我们扩展了非常有限的控制 - 控制格式函数行为的能力 - 来真正实现控制，即执行原始机器代码。查看类似于wu-ftpd2.6.0以下版本的代码：		
``` 
{
char    buffer[512];
snprintf (buffer, sizeof (buffer), user);
buffer[sizeof (buffer) - 1] = ’\0’;
}
```
在上面的代码中，无法通过插入某种“扩展”格式参数来扩大缓冲区，因为程序使用安全snprintf函数
来确保我们无法超出缓冲区。起初看起来好像我们不能做很多有用的事情，除了崩溃程序和检查一些内存。

让我们记住提到的格式参数。有‘%n’参数，它将已打印的字节数写入我们选择的变量中。通过将证书指针作为参数放入堆栈，将变量的地址赋予格式函数。

``` 
int     i;
printf ("foobar%n\n", (int *) &i);
printf ("i = %d\n", i);
```

将会打印“i=6”。使用上面用于从任意地址打印内存的相同方法，我们可以写入任意位置：
	
	"\xc0\xc8\xff\xbf_%08x.%08x.%08x.%08x.%08x.%n"
		
上面的格式字符串将覆盖xbfffc8c0处的四个字节，并带有一个小整数。我们达到了我们的目标之一：我们可以写入任意地址。但我们无法控制我们正在编写的数字 - 但这在改变。

我们写入的数字 - 格式函数写的字符数 - 取决于格式字符串。由于我们控制格式字符串，我们至少可以通过写入更多或更少的字节来影响此计数器：
``` 
int     a;
printf ("%10u%n", 7350, &a);
/* a == 10 */
int     a;
printf ("%150u%n", 7350, &a);
/* a == 150 */
```
	
通过使用为参数‘%nu’，我们能够控制由‘%n’写入的计数器，至少一bit。但是对于写入大数字 - 例如地址 - 这还不够，所以我们必须找到一种写入任意数据的方法。

x86体系结构中的整数存储在四个字节中，这些字节是小端排序（低地址存低位）的，最低有效字节是内存中的第一个字节。因此一个像0x0000014c这样的数字存储在内存中：“\x4c/\x01\x00\x00”。对于格式函数中的计数器，我们可以通过使用伪‘%nu’参数来控制最低有效字节，即存储在存储器中的第一个字节来修改它。
例：	
``` 
unsigned char    foo[4];
printf ("%64u%n", 7350, (int *) foo)
```
当printf函数返回时，foo[0]包含‘\x40’，它等于64，我们用来增加计数器的数字。

但是对于一个地址，我们必须完全控制四个字节。如果我们无法一次写入四个字节，我们可以尝试连续四次写入一个字节。在大多数CISC架构中，可以写入未对齐的任意地址。这可以用于写入存储地址的存储器的第二个最低有效字节。这看起来像：	

``` 
unsigned char   canary[5];
unsigned char   foo[4];
memset (foo, ’\x00’, sizeof (foo));
/* 0 * before */ strcpy (canary, "AAAA");
/* 1 */  printf ("%16u%n", 7350, (int *) &foo[0]);
/* 2 */  printf ("%32u%n", 7350, (int *) &foo[1]);
/* 3 */  printf ("%64u%n", 7350, (int *) &foo[2]);
/* 4 */  printf ("%128u%n", 7350, (int *) &foo[3]);
/* 5 * after */ printf ("%02x%02x%02x%02x\n", foo[0], foo[1],
foo[2], foo[3]);
printf ("canary: %02x%02x%02x%02x\n", canary[0],
canary[1], canary[2], canary[3]
```

返回输出“10204080”和“canary：00000041”。我们覆盖了我们指向的证书的最低有效字节的四倍。通过每次增加指针，最低有效字节移动通过我们想要写入的内存，并允许我们存储完全任意的数据。

正如你在图中的第一行中所看到的那样，我们的覆盖代码还没有触及所有八个字节。从第二行开始，我们触发四次覆盖，每一步都向右移一个字节。最后一行显示了最终的所需状态：我们覆盖了foo数组的所有四个字节，但在这样做时，我们销毁了canary数组的三个字节。我们加入了canary数组只是为了看到我们覆盖了我们不想要的内存。
		![][7]
				
虽然这种方法看起来很复杂，但它可以用来覆盖任何地址的任意数据。为了解释，我们到模卡位置每个格式字符串仅使用一次写入，但也可以在一个格式字符串中多次写入：
``` 
strcpy (canary, "AAAA");
printf ("%16u%n%16u%n%32u%n%64u%n",
1, (int *) &foo[0], 1, (int *) &foo[1],
1, (int *) &foo[2], 1, (int *) &foo[3]);
printf ("%02x%02x%02x%02x\n", foo[0], foo[1],
foo[2], foo[3]);
printf ("canary: %02x%02x%02x%02x\n", canary[0],
canary[1], canary[2], canary[3]);
```

我们使用‘1’惨呼作为‘%u’填充的为参数。此外，填充已更改，因为当我们要写32时，字符的计数器已经是16。所以我们只需要添加16个字符而不是32个字符，以获得我们想要的结果。

这是一种特殊情况，其中所有字节在整个写入期间都增加了。但我们也是可以写一个80 40 20 10，只做一点修改。由于我们写入整数并且顺序是小端，因此在写入中只有最低有效字节很重要。通过在触发“%n”时分别使用0x80，0x140，0x220，0x310字符的计数器，我们可以构造所需的字符串。计算所需的实际写入长度计数器的代码是这样的：		
``` 
write_byte += 0x100;
already_written %= 0x100;
padding = (write_byte - already_written) % 0x100;
if (padding < 10)			//>转义错误 
padding += 0x100;
```

其中“write_byte”是我们想要创建的字节，“already_written”是格式化函数维护的写入字节的当前计数器，“padding”是我们必须增加计数器的字节数。
例：		
``` 
write_byte = 0x7f;
already_written = 30;
write_byte += 0x100;      /* write_byte is 0x17f now */
already_written %= 0x100; /* already_written is 30 */
/* afterwards padding is 97 (= 0x61) */
padding = (write_byte - already_written) % 0x100;
if (padding < 10)		//>转义错误
padding += 0x100
```
现在格式字符串“%97u”会增加‘%n’计数器，因此最低有效字节等于‘write_byte’。最后检查如果填充低于10则值得注意。一个简单的整数输出，例如“%u”，能生成长度最多为10个字符的字符串，具体取决于它输出的整数。（取决于格式化函数运行的系统的默认单词大小，我们在此假设基于ILP32架构）如果所需的长度大于我们指定的填充，假设我们想要输出带有“%2u”的‘1000’，我们的值将被删除，有利于不丢失任何有意义的输出。通过确保填充总是大于10，我们可以保持始终准确的‘already_written’数，格式函数维护的计数器，因为我们总是写出与格式参数中的length选项指定的输出字节完全相同的输出字节。

以动手实践的方式利用这些漏洞的唯一剩余事情是将按正确顺序放在堆栈上并使用stackpop序列来增加堆栈指针。它应该看起来像：
			
			A
	<stackpop><dummy-addr-pair * 4><write-code>
		
stackpop用于增加堆栈指针的对战弹出参数序列。一旦处理了stackpop，格式函数内部堆栈指针指向dumm-addr-pair字符串的开头

dummy-addr-pair四队虚拟整数值和要写入的地址。每对地址增加1，虚拟整数值可以是任何不包含NUL字节的值。

write-code格式字符串中实际写入内存的部分，使用‘%nu%n’对，其中n大于10，第一部分用于增加或溢出最低有效字节格式函数内部字节写入计数器，‘%n’用于将此计数器写入字符串的dummy-addr-pair部分内的地址。
		
必须修改写代码以匹配stackpop写入的字节数，因为当格式函数解析写代码时，stackpop已经将字符写入输出 - 格式函数计数器不从零开始，这有被考虑。

我们写入的地址成为Return Address Location（返回地址位置），short retloc，我们在这个地方用我们的格式字符串创建的地址称为返回地址，简称为retaddr
		

# 4.漏洞利用的变化
漏洞利用是一门艺术。就像在任何艺术中一样，有多种方法可以完成任务。通常，你不希望采用正常的方式来利用事物，而是利用你的目标环境，试验，揭露并使用存在在程序中的行为。这种额外的努力可以在很多方面得到回报，首先是你的漏洞利用的可靠性和稳健性。或者，如果只有一个平台或系统收到漏洞的影响，你可以利用特殊系统功能找到要利用的快捷方式。有很多东西可以使用，这只是常见技术的基本概述。
		
## 4.1short write
除了写入四次之外，还可以仅使用两次写入操作来覆盖地址。这可以通过正常的‘%n’操作和具有大‘n’值的‘%nu’字符串实现。但是对于这种特殊情况，我们可以利用特殊的写操作，它写入short int类型：‘%hn’参数。‘h’也可用于其他格式参数，以将堆栈上提供的值转换为short类型。short写技术比第一种技术有一个有点：它不会破坏附近的数据，因此如果你要覆盖的地址后面有有价值的数据，例如函数参数，则会保留该数据。

但是一般来说你应该避免使用它，尽管大多数C库都很支持它：它依赖于格式函数的行为，即如果写入的字符的内部计数器可以超过缓冲区边界。这不适用于旧的GNU C库（libc5）。它还会在目标进程中消耗更多内存。
		
``` 
printf ("%.29010u%hn%.32010u%hn",
1, (short int *) &foo[0],
1, (short int *) &foo[2]);
```
这对于基于RISC的系统特别有用，它对‘%n’指令有对齐限制。通过使用短限定符，可以在软件中模拟对齐，或者使用特殊的机器指令，并且通常可以在每两个字节边界上进行写操作。

除此之外，它的工作方式与四字节技术完全相同。有些人甚至说可以通过使用特别大的填充来一次性写入，例如‘%。.3221219073u’。但实践证明，它在大多数系统上都不起作用。门户网站的文章首次展示了对这以主题的深入分析。在早起发布的HERT论文中可以找到一些其他好的笔记。
			
## 4.2stack poping
如果格式字符串太短而无法提供将到达你字节的字符串的堆栈弹出序列，则可能会出现问题。这是格式字符串的实际距离与格式字符串的大小之间的竞争，你必须至少弹出实际距离。因此，需要一种有效的方法来尽可能少地增加堆栈指针。目前我们只使用‘%u’序列来显示原理，但有更有效的方法。‘%u’序列长度为两个字节，弹出四个字节，得到1：2字节比（我们先投入一个字节来获得两个字节）。

通过使用‘%f’参数，我们甚至可以在堆栈中提取前8给字节，而只投入两个字节。但是这又一个很大的缺点，因为如果堆栈中的垃圾被打印为浮点数，则可能会有零除，这会使进程崩溃。为了避免这种情况，我们可以使用一个特殊的格式限定符，它只打印浮点数的整数部分：‘%.f’将向上移动八个字节，在缓冲区中只使用三个字节。

根据BSD派生和IRIX，可以滥用‘*’ - 限定符用于我们的目的。它用于动态提供格式参数将残生的输出长度。‘%10d’打印10个字符，‘%*d’动态检索输出的长度：堆栈上的下一个格式参数提供它。因为上面提到的libC允许类型‘%*******d’的参数，所以我们可以每个‘*’拉四个字节，这与四个比例相关。这会产生另一个问题：在大多数情况下我们无法预测输出长度，因为它是从堆栈内容动态设置的。

但是我们可以通过在所以开始后面发出一个硬编码值来覆盖动态规范：‘%********10d’将始终打印10个字节，无论之前从堆栈中偷看什么。着些技巧是lorian发现的。
		
## 4.3直接参数访问
除了改进堆栈弹出方法之外，还有种巨大的简化， 称为“直接参数访问”，一种直接从格式字符串中寻址堆栈参数的方法。几乎所有 当前使用的C库都支持，这些功能，但并非所有功能都可用于应用此方法来格式化字符串利用。

直接参数访问由’$’限定符控制:
	
	printf (“%6 $ d \ n”, 6,5,4,3,2,1) ;
打印'1’，因为'6 $’ 显式地处理堆栈上的第6个参数。使用 此方法可以省略整个堆栈弹出序列。	
``` 
char    foo[4];
printf ("%1$16u%2$n"
"%1$16u%3$n"
"%1$32u%4$n"
"%1$64u%5$n",
1,
(int *) &foo[0], (int *) &foo[1],
(int *) &foo[2], (int *) &foo[3]);
```
将在foo中创建“\ x10 \ x20 \ x40 \ x80”。这种直接访问仅限于BSD派生的前八个参数，IRIX除外。 Solaris C库将其限制为前30个参数，如户网站所示。如果你选择负值或巨大值， 以便在当前位置下方访问堆栈参数，则不会产生预期结果但会崩溃。

尽管它大大简化了开发，但你应尽可能使用stackpop技术，因为它使您的漏洞利用更具可移植性。如果你想利用的bug只存在于允许这种方法的一个平台上，你当然可以利用它(例如LSD利用IRIX telnet守护进程做这个)。


# 5.Brute Forcing（暴风算法）
当利用诸如缓冲区溢出或格式字符串漏洞之类的漏洞时，它经常会失败，因为最后的障碍没有得到解决：使所有偏移正确。基本上找到正确的抵消意味着“在哪里写什么”。对于简单的漏洞， 你可以通过一个接一个地尝试来可靠地猜测正确的偏移，或者只是暴力破解它。但是一 旦你需要多个偏移量，这个问题就会呈指数增长，结果证明这是不可能的。

对于格式字符串，只有在你利用守护程序或任何只提供一次尝试的程序时，才会出现此问题。只要你有多次尝试或者你可以看到格式字符串的响应，就可以找到所有必要的偏移量，但这并非易事。

这是可能的，因为我们在完全接管之前已经对目标进程进行了有限的控制：我们的格式字符串已经指示远程进程做什么，使我们能够查看内存或测试某些行为。

 由于这里解释的两种方法差别很大，因此它们是分开解释的。

## 5.1  基于响应的Brute Force

利用看到打印格式的回复首先在tf8对wu-ftpd 2.6.0的最流行的格式字符串漏洞中观察到。  他用回复来确定距离。

Smiler和我自己开发了这种技术，以确定另外两个地址，返回地址‘retaddr’ 和返回地址位置‘retloc’，并用它构建一个完全偏移的独立wu-ftpd 漏洞利用。

要使距离变粗，你应该使用如下格式字符串：
	
	“AAAABBBB|stackpop|%08x|”
stackpop取决于我们想要猜测的距离。每次尝试都会增加距离：
		
``` 
while (distance > 0) {
strcat (stackpop, "%u");
distance -= 4;
}
```
如果我们探测距离32，格式字符串将如下所示：
		
		"AAAABBBB|%u%u%u%u%u%u%u%u|%08x|"

我们从堆栈中弹出32个字节（8 *“%u”）并在堆栈十六进制的第32个字节处打印四个字节。在理想情况下， 输出看起来像：
	 
	 AAAABBBB|983217938177639561760134608728913021|41414141|

 ‘41414141’ 是‘AAA’的十六进制表示， 我们已达到32字节的确切距离。 如果通过增加距离无法达到此模式，则可能有两个原因：距离太大而无法到达，例如，如果格式字符事位于堆上，或者对齐不在四字节边界上。在后一种情况下，我们只需要在格式字符串前加一到三个虚拟字节。然后我们可以滑 动字符事位置，以便模式‘42414141’变为正确的模式‘41414141’。

一旦你有对齐和距离你就可以开始强制执行格式字符串缓冲区地址。因此， 你使用像这样的格式字符串：
	
	addr|stackpop|______________________________%%|%s

格式字符串从左到右处理，‘addr’和‘___’序列不会做任何有害的事情。stackpop'向上移动堆栈指针，直到它指向‘addr’地址。  最后，‘%s’现在从‘addr’打ASCIIZ字符串。

在理想情况下， "addr”将指向我们格式字符串的‘___’序列。在这种情况下，输出看起来像：

     garbage|___________________________%|______%%|%s||

 ‘garbage’由‘addr’和‘stackpop’输出组成。然后处理后的‘%%’字符串转换为‘%’，因为‘%%’通过格式处理转换为‘%’。那么字符串‘______%%|%s|’插入时，我们提供的格式字符串的‘%s’被处理。 请注意，这是因为我们为‘addr’尝试不同的值而变化的唯一因素。在我们理想的情况下， 我们使用了一个直接指向缓冲区的“addr”。正如你所看到的， 通过查看‘%%’，我们可以区分指向格式字符串的地址(具有两个%字符的地址)和意外指向目标缓冲区的地址(只有一个‘%’)字符，因为它是由格式函数转换的)。

如果‘addr’命中目标缓冲区，输出如下:

	 garbage|___________________________%|______%|

如你所见，只有一个‘%’可见。“这允许我们准确地预测目标缓冲区地址，这对于格式字符串缓冲区在堆本身中的情况很有用。

因为我们知道‘%s’与我们的格式字符串start相对的位置，并且我们有一个指向缓冲区的地址，所以我们可以重新定位地址，以便我们确切知道格式字符串的起始地址。由于你通常也希望将shellcode放入格式字符串中， 因此可以精确计算相对于格式字符串地址的retaddr。

## 5.2  盲目Brute Forcing

盲目Brute Forcing并不像基于响应的Brute Forcing那样直接。基本思想是我们可以测量远程计算机处理格式字符串所需的时间。像“ %.99999u”这样的字符串比简单的“%u”要长。此外，我们可以通过在未映射的地址上使用“%n”来可靠地产生分段错误。

这种Brute Forcing的基本方法是由tf8发明的，后来由我自己改进，也Brute Forcing缓冲地址。

 由于此攻击相对复杂且仅对特殊情况有用，因此我在示例/目录中提供了一个工作示例。有趣的是， 你可以多次触发漏洞，但是你没有看到格式函数的响应，例如在syslogs的服务中。

如果你对这种技术感兴趣，请查看来源，我在这里省略了描述，抱歉。

# 6.特别案例
在某些情况下，你可以利用这种情况，不必知道所有补偿，或者你可以使开发更简单，更直接和最重要:可靠。我列出了一些在这里利用格式字符审漏洞的常用方法。

 ## 6.1 替代目标
由于基于堆栈的缓冲区溢出的悠久历史影响，很多人认为覆盖存储在堆栈中的返回地址是获取对进程的控制的唯一方法。但是如果我们利用格式字符串漏洞，我们就不知道我们的缓冲区在哪里，我们可以覆盖其他的东西。基于堆栈的常见缓冲区溢出仅允许返回地址覆盖，因为它们也存储在堆栈中。但是使用格式化函数，我们可以在内存中随处写入，允许我们修改整个可写入的进程空间。

因此，有必要研究其他方法来获取对被利用过程的部分或完全控制。在某些情况下，这可以导致更容易的剥削方式，或者 - 正如我们将看到的 - 可以用来规避某些保护措施。

我将在此简要讨论替代地址位置，并参考更深入的文章。

### 6.1.1 GOT覆盖

任何ELF二进制文件的进程空间包括一个特殊部分，称为“全球抵消表”(GOT)。程序使用的每个库函数都有一个 条目，其中包含实际函数所在的地址。这样做是为 了允许在进程内存中轻松重定位库，而不是使用硬编码地址。在程序第一次使用该函数之前，该条目包含运行时链接程序(rt1)的地址。如果程序调用该函数， 则将控制传递给rtl,并解析函数实地址并将其插入GOT。每次调用该函数都会直接将控件传递给它，并且不再调用该函数的rtl。有关通过GOT进行开发的更完整概述，请参阅我们Lam3rZ兄弟的优秀文章。通过覆 盖函数的GOT条目，程序将在利用格式字符串漏洞后使用，我们可以抓住控制并跳转到任何可执行的地址。不幸的是， 这意味着任何基于堆栈的保护都会对返回地址执行检查失败。

 我们通过覆盖G0I条目获得的巨大优势是它独立于环境变量(例如堆栈)和动态内存分配(堆)。GOT条 目的地址仅对每个二进制文件是固定的，因此如果两个系统具有相同的二进制文件运行，则GOT条目始终位于同一地址。

你可以通过运行来查看函数的GOT条目的位置:

objdump --动态重定位的二进制

真实函数(或rtl链接函数)的地址直接在打印地址。

 另一个非常重要的因素，为什么使用GOT条目来获取控制而不是返回地址是表单的代码(在一些‘安全’指示服务守护进程中找到) ;

    syslog (LOG_NOTICE, user);
	exit (EXIT_FAILURE)；

你不能通过覆盖可靠的返回地址来控制这里。你可以尝试在此处覆盖syslog自己的返回地址，但更可靠的方法是覆盖‘exit’函数的GOIT条目，该函数会在调用‘exit’时将执行传递给你指定的地址。

但是GOT技术最有用的优点是易于使用，你只需要运行objdump并且你有覆盖的地址(retloc) 。黑客在打字时很懒散(除了马虎)。

### 6.1.2  DTORS

使用GNU C编译器编译的二进制文件包含一个特殊的析构函数表部分，称为"DTORS"。在完成所有常见的清理操作之后， 在发出真正的“退出“系统调用之前调用此处列出的析构函数。DTORS部分具有以下格式:

	DTORS：0xffffffff 0x00000000 ...

 第一个条目是一个计数器，如果列表为空，则该计数器保存跟随或减去一个的函数指针的数量(如这里的情况)。在DTORS部分的所有 实现中，将忽略此字段。  然后，在相对偏移量+4处，存在清除函数的地址，由NULL地址终止。你可以使用指向shellcode的指针覆盖此NULL指针，并且只要程序退出，你的代码就会被执行。

### 6.1.3  C库钩子

几个月前，Solar Designer引入了一种新技术，可以在malloc-allocates内存中利用基于堆的溢出。他建议覆盖GNU C库和其他一些专有库中的钩子。通常,此挂接由内存调试和分析工具使用，以便在应用程序分配或使用malloc接口释放内存时发现。有 一些钩子，但最常见的是__malloc_hook, __realloc_ hook和__free_hook。通常它们被设置为NULL,但是只要用指向代码的指针覆盖它们，代码就会被执行，因为malloc, realloc和free都被调用。 由于钩子通常用作调试钩子，因此在执行实际函数之前调用它们。

有关malloc-overwrite技术的讨论在Solar Designers Advisory 中就Netscape JPEG解码器漏洞进行了讨论。
	  
### 6.1.4  __atexit 结构

同样在几个月前，Kalou介绍了一种在Linux下利用静态链接二进制文件的方法，它利用了一个名为“__atexit”的通用处理程序，它会在程序调用退出时立即执行。这允许程亨设置许多将在退出时调用的处理程序，以释放资源。关于atexit结构攻击的详细讨论可以在Pascal Bouchareines的论文中找到。

### 6.1.5  函数指针

如果受害者应用程序使用函数指针，则可能会覆盖它们。要使用它们， 你必须覆盖它然后触发它们。一些守护进程使用函数指针表进行命令处理，例如QPOP。此外，函数指针通常用于模拟类似atexit的处理程序，例如在SSHd中。

### 6.1.6  jmpbuf

首先使用jmpbuf覆盖技术来利用堆字储的缓冲区。对于格式字符串，jmpbuf的行为就像函数指针一样，因为我们可以在内存中的任何地方写入，而不受jmpbuf到缓冲区的相对位置的限制。在Shok关于堆益出的论文中可以找到深入的讨论。

## 6.2返回LibC

你可以使用常见的返回到LibC技术，再次开创一Solar Designer。但有时可能会有一个捷径，这会导致更容易的利用:
	
	FILE *  f;
	char    foobuf[512];
	snprintf (foobuf, sizeof (foobuf), user);
	foobuf[sizeof (foobuf) - 1] = ’\0’;
	f = fopen (foobuf, "r");

你可以使用‘system’函数的地址覆盖‘fopen’的GOT地址。然后使用格式字符串，例如：
	
	"cd /tmp;cp /bin/sh .;chmod 4777 sh;exit;"
	"addresses|stackpop|write"
		
其中‘addresses’，‘stackpop’和‘write’是常见的格式字符串开发序列。它们用于用‘ system’的地址覆盖‘fopen’的GOI条目。当‘ fopen’被调用时，字符串被传递给‘system’函数。或者，你可以使用常见的旧方法，如下所述。

## 6.3  多次打印

如果你可以在同一进程中多次触发格式字符串漏洞(例如在wu-ftpd中)，则可以覆盖更多，然后只覆盖返回地址。  例如，你可以将整个shellcode存储在堆上，以规避任何不可执行的堆栈保护。与此处介绍的其他技术i起，你可以绕过以下保护设施(当然不完整) ;

	  。StackGuard

      。StackShield

      。Openwall内核补丁(由Solar Designer提供)
	  
	  。 libsafe

2000年10月中旬，一群人发布了一系列称为PaX的Linux内核补丁，有效地允许实现可读写但不可执行的页面。由于在x86 CPU系列上无法做到这一点，因此补丁使用了Plex CPU仿真器项目发现的一些技巧。在运行此修补程序的系统上，几乎不可能执行你在流程中引入的任意shellcode。但大多数时候，进程空间本身已经存在有用的代码。我们可以执行此代码来执行我们通常在shellcode中执行的操作。

使用常见的Return-into-LibC技术你可以规避这种保护。最简单的情况是使用格式字符串作为参数返回system ()库函数。

 通过稍微优化字符串，你可以将强制性偏移减少到只知道一个: system()函数的地址。要调用程序， 可以在格式字符串的末尾使用此序列：

	";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;id > /tmp/owned;exit;"

 任何指向‘;’的地址字符并传递给system ()函数将执行命令，因为‘:’字符对shell执行’nop’命令。

 ## 6.4  Heap中的格式字符串

到目前为止，我们假设格式字符串始终位于堆栈上。但是，有些情况下，它存储在堆上。如果堆栈 上有另一个缓冲区，我们可以影响我们可以使用那个缓冲区提供要写入的地址，但是如果没有这样的缓冲区，我们只剩下很少的选择。

如果目标缓冲区位于堆栈上，我们可以先打印到它，然后使用那里的地址，使用‘%n’参数进行写入：
``` 
void
func (char *user_at_heap)
{
char    outbuf[512];
snprintf (outbut, sizeof (outbuf), user_at_heap);
outbuf[sizeof (outbuf) - 1] = ’\0’;
return;
}
```
在这里，我们像往常一样使用包含我们要写入的地址的格式字符串。但有什么特别之处，就是我们不从格式字符串本身访问这些地址，而是从目标缓冲区访问。要做到这一点，我们必须首先将地址存储在堆栈上，只需打印它们即可。因此，写序列必须位于格式字符串中的地址之后。

如果两个缓冲区都不在堆栈中，我们就会遇到问题：		
``` 
void
func (char *user_at_heap)
{
char *  outbuf = calloc (1, 512);
snprintf (outbut, 512, user_at_heap);
outbuf[511] = ’\0’;
return;
}
```

现在取决于我们是否有某种方式在堆栈上提供数据。例如， wu-ftpd的一些漏洞使用密码字段来存储数据(shellcode, 而不是地址一这些漏洞不能利用非匿名帐户)。

每个漏洞和漏洞利用都是不同的，人们应该花费数小时研究漏洞，然后再声明漏洞是不可利用的，即使这样，有些情况下你也错了，因为不仅格式字符串漏洞的历史已经显示出来。  (嗨，OpenBSD团队! :-)。

## 6.5  特别考虑

除了开发本身之外，还有一些事情需要考虑。如果shellcode包含在格式字符串中，则它可能不包含‘x25’(%) 或NUL字节。但是由于 没有重要的操作码既不是0x25也不是0x00,因此在构造shellcode时不会遇到问题。 如果地址也存储在格式字符串中，情况也是如此。如果 要写入的地址在最低有效字节中包含NUL字节，则可以在要存储字节的地址正下方的奇数地址上用短写替换它。但是，这在所有体系结构上都是不可能的。此外，你可以使用两个单独的格式字符串。第一个创建你想在整个字符串后面的内存中写入的地址 。第二个使用此地址写入它。 

 这可能很快变得复杂，但允许可靠的利用，有时值得努力。

# 7.工具

一旦漏洞利用完成，甚至在漏洞利用开发中，使用工具检索必要的偏移量也是有帮助的。某些工具还可以帮助识别漏洞， 例如封闭源软件中的格式字符串漏洞。我在这里列出了四个工具，对我来说非常有帮助，也可能适合你。

## 7.1 ltrace, strace
 ltrace [8]和strace [9以类似的方式工作:它们挂钩库和系统调用，记录它们的参数并返回值，就像程序调用它们一样。这使你可以观察程序如何与系统交互，将程序本身视为黑盒子。

所有现成的格式函数都是车调用及其参数，最重要的是它们的地址可以使用1trace来观察。这样，你可以在任何可以进行ptrace的过程中快速确定格式字符串的地址。strace程序用于获取读取数据的缓冲区的地址，例如，如果调用read来读取稍后用作格式字符串的数据。

 要了解这两个工具的用法，可以节省大量时间，在尝试将GDB附加到具有缺失符号和编译器优化的过时程序时，可以使用它来找到两个简单的偏移室。

## 7.2 GDB, objdump

GDB，经典的‘GNU Debugger’是一个基于文本的调试器，适用于源代码级别和机器代码调试。虽然它看起来不太舒服，但是一旦你习惯它，它就是程序内部的强大接口。从调试你的漏洞利用到观察被利用的进程，它非常方便。

0bjdump,来自GNU binutils包的程序,适用于检索二进制可执行文件或目标文件的任何信息，例如内存布局，部分或主函数的反汇编。我们主要使用它从二进制文件中检索G0I条目的地址。但它可以通过许多不同的有用方式为你服务。

		


  [1]: https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf
  [2]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo1.png
  [3]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo2.png
  [4]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo3.png
  [5]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo4.png
  [6]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo6.png
  [7]: https://github.com/yagamihikari123/yagamihikari123.github.io/blob/master/formatstring/photos/photo5.png